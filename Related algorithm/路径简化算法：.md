路径简化算法：

我们在计算出来对应的路径之后，也许还可以使用算法进一步减短路径的长度。在这里我们就使用基于二分查找的思想来实现我们的目标。

- 首先我们通过某种算法得到了一组$n$维的路径点数组，并且相邻两点与环境不会发生碰撞。
- 算法的逻辑就是每次选取路径的中间点与末端点进行连线，判断线路与障碍物的碰撞情况。
- 如果没有发生碰撞那么就说明从中间点$mid$出发到末端点$end$的路径可以优化成一条直线，那么我们就把这个中间点记录下来，并且把数组的中点$mid$给右端$right$;如果发生了碰撞，那么就把中点$mid$赋值给左端点$left$最后重新计算对应的中间点$mid$。
- 内侧循环直至左端点紧邻右端点则停止遍历，这时候的右端点$right$其实就是目前在该路径点中到末端点$end$的最近点.我们还要把末端点$end$更新为右端点$right$这样便于进行下一次循环
- 外侧循环遍历到右端点$end$等于2，说明该点已经是直接和起始点连接了，就把1加入数组$Array$,最后返回数组



![dzzddzdz](路径简化算法：.assets/image-20230305232930592.png)



我觉得还是画图更清晰一点，下面有五个红点代表规划路径，蓝色代表障碍物。我们要对这个例子进行优化：

第一步，检测$path(1)$最右侧的点与$path(end)$的连线是否会碰撞障碍物，答案是会碰撞

![image-20230306001134615](路径简化算法：.assets/image-20230306001134615.png)

第二步，进入内侧的$while$循环，检测$path(mid)$与$path(right)$连线是否会碰撞障碍物，答案是不会。图中紫色的单词表示下标的变更

![image-20230306001757119](路径简化算法：.assets/image-20230306001757119.png)

第三步，检测$path(mid)$与$path(end)$的连线是否会发生碰撞，答案是会发生，那么就会出现图中的下标变更，因为left+1=right，所以跳出循环

![image-20230306002013066](路径简化算法：.assets/image-20230306002013066.png)

第四步，重新检测$path(1)$最右侧的点与$path(end)$的连线是否会碰撞障碍物，答案是会碰撞，就开始进入内侧的循环

![image-20230306002111456](路径简化算法：.assets/image-20230306002111456.png)

第五步内侧循环，检测$path(mid)$与$path(right)$是否会发生碰撞，答案是不会，所以发生下面的下标变更，然后left+1=right，跳出循环

![image-20230306002635448](路径简化算法：.assets/image-20230306002635448.png)

第六步，把$right=2$也加入到$Array$之中，经过下标变换之后，$end=2$,然后就把1也加入到$Array$之中，最后反转一下数组即可

![image-20230306002912610](路径简化算法：.assets/image-20230306002912610.png)

根据上面的步骤我们可以得到新的路径为1-2-3-5，简化掉了4，而且并不会出现新的碰撞。